# Segment Tree
## 구간 트리

임병찬, 조승혁

---

## 쿼리 문제

- Input이 1개 들어올 때 Output을 출력하는게 기존 문제
- Input이 여러 개 들어올 때 적절한 Output을 출력하는게 쿼리 문제
- 기존 문제를 쿼리 문제로 나눌 수 있고, 반대로 쿼리 문제를 기존의 문제로 바꿀 수 있다.
- 그러므로, 사실 크게 의미 없는 분류다(…)

---

다음 문제를 풀어보자.

Q) A[1, 2, … , n]이 주어지며, 2종류의 쿼리가 주어진다.
- 쿼리 1 : (u, v)가 주어지면, A[u, u+1, … , v]를 출력한다.
- 쿼리 2 : (u, k)가 주어지면, A[u]에 k를 더한다. 
여러 개의 쿼리들이 주어질 때, 어떻게 풀까?

---

## Answer 1

무작정 다 더한다! 

- 쿼리 1 (u, v)가 주어지면, for문으로 u부터 v까지 더하여 출력한다.

- 쿼리 2 (u, k)가 주어지면, 그냥 A[u]에 k를 더한다.

- 쿼리 1 수행하는데 걸리는 시간 : O(n)

- 쿼리 2 수행하는데 걸리는 시간 : O(1)

정말 간단한 풀이지만, 당연하게도(?) 시간이 터진다.

---

## Answer 2
크기가 n인 array S를 정의하자. 

처음에는 S[i] = A[1] + … + A[i]로 초기화한다.

- 쿼리 1 (u, v)가 주어지면 S[v] – S[u-1]을 출력한다.

- 쿼리 2 (u, k)가 주어지면, S[u, …, n]에 k를 더한다.

- 쿼리 1 수행하는데 걸리는 시간 : O(1)

- 쿼리 2 수행하는데 걸리는 시간 : O(n)

안타깝게도, 또 터진다(…)



---

- 쿼리 문제는 쿼리를 실행하기 전 준비를 하는 전처리 시간, 

- 쿼리를 수행하는데 걸리는 시간인 후처리 시간이 존재한다.

- 대부분 전처리 시간과 후처리 시간은 반비례한다.

- 쿼리 1 수행 시간과 쿼리 2 수행 시간도 대부분 반비례한다.

- 그러므로 전처리 시간, 후처리 시간을 “적절히” 조정해야 원하는 시간 안에 수행이 가능하다.

---

A1, A2의 문제점
- A1 : 너무 잘게 잘라서 연산한다!

  첫번째 쿼리를 수행할 때 값을 한 개씩 더해주므로 시간이 오래 걸린다…

- A2 : 너무 안 잘라서 연산한다!

  첫번째 쿼리를 수행할 때 값 2개만 더하므로 두번째 쿼리를 실행할 때 수행이 너무 오래 걸린다.

그러므로, 첫번째 쿼리와 두번째 쿼리 모두 적당히 걸리는 풀이가 제일 좋은 풀이일 것이다.
이를 해결하기 위해 ‘**Interval**’을 사용한다.

---

적당한 Interval이 존재한다고 하자.

모든 Interval은 기존에 있는 적당한 Interval들을 더해서 만들 수 있다고 하자.

그렇다면, 고려해야 하는 경우의 수가 매우 줄어든다!!

이유 : 모든 Interval은 $n^2$개 정도 있는데, 적당한 Interval들의 수는 $n^2$개보다 훨씬 적기 때문.

어떻게 적당한 Interval을 만들까?

- 균등 Interval : Bucket
- 비균등 Interval : Segment Tree, Penwick Tree

---

# 수식을 테스트 하는 중

1+1=2 

$1+1=2$

$$1+1=2$$

인라인 $$1+1+2$$ 

아니면 $1+1=2$
